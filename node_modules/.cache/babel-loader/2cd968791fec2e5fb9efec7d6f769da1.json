{"ast":null,"code":"(function (exports) {\n  \"use strict\";\n\n  var fs = require('fs');\n\n  var Q = require('q');\n  /**\n   * For the supplied paths list, matches against the supplied filters and returns a new array of paths that\n   * are ordered as the list of filters would imply they should be. The filters can include * as a match-anything in\n   * one directory or ** for match any file in any directory. All filters are treated as an ends-with match.\n   *\n   * @param {String[]} paths\n   * @param {String[]} filters\n   * @return String[]\n   */\n\n\n  function file_list_filter(paths, filters) {\n    var result = [];\n    filters.forEach(function (filter) {\n      var filterRegex = new RegExp('^' + filter.replace(/\\./g, '\\\\.').replace(/(\\*?)(\\*)(?!\\*)/g, function (match, prefix) {\n        if (prefix == '*') {\n          return match;\n        }\n\n        return '[^\\\\/]*';\n      }).replace(/\\*\\*/g, '\\.*') + '$', 'i');\n      paths.forEach(function (path) {\n        if (result.indexOf(path) < 0 && path.match(filterRegex)) {\n          result.push(path);\n        }\n      });\n    });\n    return result;\n  }\n  /**\n   * Gets a flag that identifies whether the supplied path is a directory or a file, true when a directory. In the\n   * case that the file doesn't exist the result will be false.\n   *\n   * @param path\n   * @return {Boolean}\n   */\n\n\n  function is_dir(path) {\n    try {\n      return fs.statSync(path).isDirectory();\n    } catch (e) {\n      return false;\n    }\n  }\n  /**\n   * Given the name of the directory about to be traversed, checks whether it should be - allows for the automatic\n   * removal of \"hidden\" directories.\n   *\n   * @param {String} base\n   * @param {String} directoryName\n   * @param {Number} options\n   * @return {Boolean}\n   */\n\n\n  function should_read_directory(base, directoryName, options) {\n    return !(exports.NON_RECURSIVE & options) && !!(directoryName.charAt(0) != '.' || exports.INCLUDE_HIDDEN & options);\n  }\n  /**\n   * Reads the supplied directory path and builds an array of files within the directory. This will work recursively\n   * on each sub directory found. The optional appendTo argument can be used to merge file paths onto an existing\n   * array, and is used internally for recursion.\n   *\n   * @param {String} dir\n   * @param {String[]} appendTo\n   * @param {Number} prefixLength\n   * @param {Number} options\n   */\n\n\n  function read_dir_sync(dir, appendTo, prefixLength, options) {\n    var contents = fs.readdirSync(dir),\n        result = appendTo || [];\n    contents.forEach(function (itm) {\n      var newPath = dir + itm;\n\n      if (is_dir(newPath)) {\n        if (should_read_directory(dir, itm, options)) {\n          read_dir_sync(newPath + '/', result, prefixLength, options);\n        }\n\n        if (exports.INCLUDE_DIRECTORIES & options) {\n          result.push(newPath.substring(prefixLength) + '/');\n        }\n      } else {\n        result.push(newPath.substring(prefixLength));\n      }\n    });\n    return result;\n  }\n\n  function read_dir(dir, appendTo, prefixLength, options) {\n    var deferred = Q.defer();\n    fs.readdir(dir, function (err, contents) {\n      if (err) deferred_error(deferred, err, options);else if (!contents.length) {\n        deferred.resolve();\n      } else {\n        Q.all(contents.map(function (itm) {\n          var deferred = Q.defer();\n          var newPath = dir.replace(/\\/$/, '') + '/' + itm;\n          fs.stat(newPath, function (err, stat) {\n            var isDirectory = stat && stat.isDirectory();\n            if (err) deferred_error(deferred, err, options);else if (isDirectory) {\n              if (exports.INCLUDE_DIRECTORIES & options) {\n                appendTo.push(newPath.substring(prefixLength) + '/');\n              }\n\n              if (should_read_directory(dir, itm, options)) {\n                read_dir(newPath, appendTo, prefixLength, options).then(deferred.resolve, deferred.reject);\n              } else {\n                deferred.resolve();\n              }\n            } else {\n              deferred.resolve(appendTo.push(newPath.substring(prefixLength) + (isDirectory ? '/' : '')));\n            }\n          });\n          return deferred.promise;\n        })).then(deferred.resolve, deferred.reject);\n      }\n    });\n    return deferred.promise;\n  }\n\n  function deferred_error(deferred, error, options) {\n    if (exports.IGNORE_ERRORS & options) {\n      deferred.resolve();\n    } else {\n      deferred.reject(error);\n    }\n  }\n  /**\n   * Changes the values in the supplied paths array to be absolute URIs\n   *\n   * @param {String} prefix\n   * @param {String[]} paths\n   */\n\n\n  function prepend_paths(prefix, paths) {\n    paths.forEach(function (path, index) {\n      paths[index] = prefix + path;\n    });\n  }\n\n  function sort_paths(paths, sorter) {\n    return paths.sort(sorter);\n  }\n\n  function caseless_sort(pathA, pathB) {\n    var a = ('' + pathA).toLowerCase(),\n        b = ('' + pathB).toLowerCase();\n\n    if (a == b) {\n      return 0;\n    } else {\n      return a > b ? 1 : -1;\n    }\n  }\n\n  function case_sort(pathA, pathB) {\n    if (pathA == pathB) {\n      return 0;\n    } else {\n      return pathA > pathB ? 1 : -1;\n    }\n  }\n\n  function apply_filters(basePath, allFiles, includeFilters, options) {\n    if (Array.isArray(includeFilters)) {\n      allFiles = file_list_filter(allFiles, includeFilters);\n    }\n\n    if (exports.ABSOLUTE_PATHS & options) {\n      prepend_paths(require('path').resolve(process.cwd(), basePath) + '/', allFiles);\n    }\n\n    if (exports.CASELESS_SORT & options) {\n      allFiles = sort_paths(allFiles, caseless_sort);\n    }\n\n    if (exports.CASE_SORT & options) {\n      allFiles = sort_paths(allFiles, case_sort);\n    }\n\n    return allFiles;\n  }\n  /**\n   *\n   * @param {String} basePath\n   * @param {String[]} [includeFilters]\n   * @param {Number} [options]\n   */\n\n\n  exports.readSync = function (basePath, includeFilters, options) {\n    var rootDir = basePath.replace(/\\/$/, '') + '/';\n\n    if (!fs.existsSync(rootDir)) {\n      return [];\n    } else {\n      return apply_filters(basePath, read_dir_sync(rootDir, [], rootDir.length, options), includeFilters, options);\n    }\n  };\n  /**\n   *\n   * @param {string} basePath\n   * @param {string[]} includeFilters\n   * @param {number} options\n   * @param {Function} handler\n   */\n\n\n  exports.read = function (basePath, includeFilters, options, handler) {\n    var callback = handler;\n\n    var assert = require('assert');\n\n    assert.equal(typeof basePath, 'string', 'basePath must be a string');\n    assert.equal(typeof arguments[arguments.length - 1], 'function', 'last argument must be a function');\n\n    switch (arguments.length) {\n      case 2:\n        callback = includeFilters;\n        includeFilters = null;\n        options = 0;\n        break;\n\n      case 3:\n        callback = options;\n\n        if (typeof includeFilters === \"number\") {\n          options = includeFilters;\n          includeFilters = null;\n        } else {\n          options = 0;\n        }\n\n    }\n\n    assert.ok(Array.isArray(includeFilters) || includeFilters === null, 'includeFilters must be null or an array of filters');\n    assert.equal(typeof options, 'number', 'options must be set as a number');\n    var rootDir = basePath.replace(/\\/$/, '') + '/',\n        allFiles = [];\n    read_dir(rootDir, allFiles, rootDir.length, options).then(function () {\n      callback(null, apply_filters(basePath, allFiles, includeFilters, options));\n    }, function (err) {\n      callback(err, []);\n    });\n  };\n\n  exports.isDir = is_dir;\n  /**\n   * Bitwise option for making the return paths absolute URIs instead of being from the supplied base path\n   * @type {Number}\n   */\n\n  exports.ABSOLUTE_PATHS = 1;\n  /**\n   * Bitwise option for making the return array sorted case insensitively\n   * @type {Number}\n   */\n\n  exports.CASELESS_SORT = 2;\n  /**\n   * Bitwise option for making the return array sorted case sensitively\n   * @type {Number}\n   */\n\n  exports.CASE_SORT = 4;\n  /**\n   * Bitwise option for making the return array sorted case sensitively\n   * @type {Number}\n   */\n\n  exports.INCLUDE_DIRECTORIES = 8;\n  /**\n   * Bitwise option for preventing the automatic removal of paths that start with a dot\n   * @type {Number}\n   */\n\n  exports.INCLUDE_HIDDEN = 16;\n  /**\n   * Bitwise option for preventing the directory reader running recursively\n   * @type {Number}\n   */\n\n  exports.NON_RECURSIVE = 32;\n  /**\n   * Bitwise option for preventing errors reading directories from aborting the scan whenever possible - includes\n   * incorrectly rooted relative symlinks and missing root directory.\n   * @type {number}\n   */\n\n  exports.IGNORE_ERRORS = 64;\n})(typeof module == 'undefined' ? window.ReadDir = {} : module.exports);","map":null,"metadata":{},"sourceType":"script"}